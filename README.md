arduino-rust
============

This is a personal project of mine to learn both Rust and embedded systems programming. My code was developed for
an Arduino Uno R3 from Elegoo. I aim to implement a "firmware update" functionality.

The contents of the **How to run** and **License** section were autogenerated by following the instructions to
initialize a project at <https://github.com/Rahix/avr-hal>.

## Observations

*last edited on 03 April 2025*

### Bootloader details

[Optiboot](https://github.com/Optiboot/optiboot) (or at least an older version) claims to be installed by default
on all Arduino Uno boards, so I can expect the bootloader to be 512 bytes in size. However, to avoid any tomfoolery
stemming from running Rust on Arduino and any potential differences due to using an older version of Optiboot and
to also deepen my understanding of embedded systems, AVR assembly, and the overall microarchitecture of the
ATmega328p, I decided to verify it myself by writing code to check the relevant bits. This code is located in
`src/bootbits.rs`.

#### Results
Running the code in `src/bootbits.rs` gave me the following console output:[^1]
```
Value of lock bits: 15     # Corresponds to 0b00001111
Value of boot bits: 222    # Corresponds to 0b11011110
```

I followed the [instructions](https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204962)
given by the datasheet for the ATmega328p to extract the lock bits and the fuse high byte. Note this information from the documentation:

```
Lock bits

Bit        7        6        5        4        3        2        1        0
Rd     [   -   ][   -   ][ BLB12 ][ BLB11 ][ BLB02 ][ BLB01 ][  LB2  ][  LB1  ]
```
```
Fuse high bits

Bit        7        6        5        4        3        2        1        0
Rd     [  FHB7 ][  FHB6 ][  FHB5 ][  FHB4 ][  FHB3 ][  FHB2 ][  FHB1 ][  FHB0 ]

FHB2 corresponds to BOOTSZ1 bit
FHB1 corresponds to BOOTSZ0 bit
FBH0 corresponds to BOOTRST bit
```

We now know the following information from the lock bits:
- `LB2` and `LB1` are both `1`; we are able to read and write the flash memory in serial and parallel mode. [^2]
- `BLB12` and `BLB11` have been set to `0`; the bootloader section of the flash memory is RW-protected. `BLB02` and `BLB01` have been set to `1`; we can freely read and write the application section of the flash memory. [^3]

From the fuse high bits, we now know the following information:
- `BOOTSZ1` and `BOOTSZ0` are both `1`; this means that our bootloader is 256 words. Each AVR instruction (word) is 2 bytes... so as expected, our bootloader is 512 bytes. [^4]
- `BOOTRST` is set to `0`; from my understanding, this means we jump to the bootloader when we reset? [^5]

#### Implications

When allowing firmware updates, we need a way to recover from a bad update and also track the status of our system. From my intuition, the `BOOTRST` fuse being set to `0` and the `BLB11` and `BLB12` bits being set to `1` mean
that we have a locked bootloader and that we probably boot into the bootloader, which then jumps us into the program once the boot sequence is complete. Regardless of what approach we choose, I think our best best is to
split the flash memory into *roughly* two equal chunks, corresponding to an original and backup program.

My gut feeling is that the bootloader mostly sets stuff up internally and jumps to `0x0000`. Disassembling the `.elf` file generated by Rust has it so that the `.text` section of the file starts with a bunch of vectors anyway,
with the end result being we jump to `0x0068`. We do some setup code from there and eventually jump into what would correspond to the entry point defined in our code.
```assembly
00000092 <.do_clear_bss_loop>:
    st      X+, r1
00000094 <.do_clear_bss_start>:
    cpi     r26, 0xA6
    cpc     r27, r18
    brne    .-8
    call    0x176        ; 0x176 <main>
    jmp     0x3a2        ; 0x3a2 <_exit>
...
00000176 <main>:
#[arduino_hal::entry]    ; address 0x0176 in disassembly
    call    0x017a       ; seems pointless? but what would I know LOL
fn main() -> ! {         ; address 0x017a in disassembly
    push    r12
    push    r13
```
Now, what does this actually mean for my project development from now on? I might consider taking a conservative approach and setting `BLB12` to `1` so we allow ourselves to at least read the bootloader. Maybe we could
dump the contents of the bootloader and pass it into an AVR assembler to see what we get. If it doesn't seem like the bootloader isn't doing much other than a jump to `0x0000` or something, we could always just set
`BOOTRST` to `1` (?) and set the boot locker bits (`BLBxx`) to `1` to have a fully unlocked bootloader. On the other hand, if there's some sort of arcane magic happening, I could try to experiment with my code in my `main()`
function and then dump the first couple hundred or thousand bytes of flash memory via console output. If we write faux-bootloader code in the beginning of the `main()` function and then delineate it with an `asm!()` block
that fills some SRAM or registers with some good old `69`s, we should be able to see where and when this happens in both our disassembled output `.elf` and the flash memory dump we did. If we keep that in mind and only
overwrite application memory past the faux-bootloader, we should be able to stop ourselves from "bricking" our board. [^6]

The EEPROM could also be a nice little place to store a faux-bootloader, but I'm not sure if we can even run instructions directly from there. It's worth considering in the future, though that path might involve raw-dogging
lots of assembly code by hand.

## How to run

1. Install prerequisites as described in the [`avr-hal` README] (`avr-gcc`, `avr-libc`, `avrdude`, [`ravedude`]).

2. Run `cargo build` to build the firmware.

3. Run `cargo run` to flash the firmware to a connected board.  If `ravedude`
   fails to detect your board, check its documentation at
   <https://crates.io/crates/ravedude>.

4. `ravedude` will open a console session after flashing where you can interact
   with the UART console of your board.

[`avr-hal` README]: https://github.com/Rahix/avr-hal#readme
[`ravedude`]: https://crates.io/crates/ravedude

## License
Licensed under either of

 - Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
 - MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

## Contribution
Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall
be dual licensed as above, without any additional terms or conditions.



[^1]:The two highest bits of the lock byte were set to `0` in my code after extraction.
[^2]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1205581
[^3]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204619
[^4]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204617
[^5]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204744
[^6]:Realistically, I don't see ourselves bricking the board, especially if we keep `BLB11` and `BLB12` set to `0` so the bootloader section of flash memory is RW-protected.
