arduino-rust
============

This is a personal project of mine to learn both Rust and embedded systems programming. My code was developed for
an Arduino Uno R3 from Elegoo. I aim to implement a "firmware update" functionality.

The contents of the **How to run** and **License** section were autogenerated by following the instructions to
initialize a project at <https://github.com/Rahix/avr-hal>.

## Bootloader analysis

*last edited on 19 April 2025*

### Bootloader details

[Optiboot](https://github.com/Optiboot/optiboot) (or at least an older version) claims to be installed by default
on all Arduino Uno boards, so I can expect the bootloader to be 512 bytes in size. However, to avoid any tomfoolery
stemming from running Rust on Arduino and any potential differences due to using an older version of Optiboot and
to also deepen my understanding of embedded systems, AVR assembly, and the overall microarchitecture of the
ATmega328p, I decided to verify it myself by writing code to check the relevant bits. This code is located in
`src/bootbits.rs`.

#### Results
Running the code in `src/bootbits.rs` gave me the following console output:[^1]
```
Value of lock bits: 15     # Corresponds to 0b00001111
Value of boot bits: 222    # Corresponds to 0b11011110
```

I followed the [instructions](https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204962)
given by the datasheet for the ATmega328p to extract the lock bits and the fuse high byte. Note this information from the documentation:

```
Lock bits

Bit        7        6        5        4        3        2        1        0
Rd     [   -   ][   -   ][ BLB12 ][ BLB11 ][ BLB02 ][ BLB01 ][  LB2  ][  LB1  ]
```
```
Fuse high bits

Bit        7        6        5        4        3        2        1        0
Rd     [  FHB7 ][  FHB6 ][  FHB5 ][  FHB4 ][  FHB3 ][  FHB2 ][  FHB1 ][  FHB0 ]

FHB2 corresponds to BOOTSZ1 bit
FHB1 corresponds to BOOTSZ0 bit
FBH0 corresponds to BOOTRST bit
```

We now know the following information from the lock bits:
- `LB2` and `LB1` are both `1`; we are able to read and write the flash memory in serial and parallel mode. [^2]
- `BLB12` and `BLB11` have been set to `0`; the bootloader section of the flash memory is RW-protected. `BLB02` and `BLB01` have been set to `1`; we can freely read and write the application section of the flash memory. [^3]

From the fuse high bits, we now know the following information:
- `BOOTSZ1` and `BOOTSZ0` are both `1`; this means that our bootloader is 256 words. Each AVR instruction (word) is 2 bytes... so as expected, our bootloader is 512 bytes. [^4]
- `BOOTRST` is set to `0`; from my understanding, this means we jump to the bootloader when we reset? [^5]

For whatever reason, `avrdude` states that the lock and high fuse bytes are both `0` when reading them with the shell command 
`avrdude -C avrconf.conf -c arduino -p m328p -P /dev/ttyACM0 -D -u -s -U hfuse:r:outfile1:h -U lock:r:outfile2:h`. This can't be right, however, because I've confirmed manually by dumping the contents of the Arduino's flash memory 
that the bootloader section occupies 512 bytes of flash memory. Furthermore, I've actually copied the functionality of `src/bootbits.rs` into a quick program I wrote using the Arduino IDE, and both my "stable" Arduino IDE
program and my Rust program to check the lock byte output the same results, meaning that it probably isn't a bug with the inline assembly code that I wrote. Also, `avrdude` seems to be exhibiting buggy behavior with sending 4-byte
serial programming instructions and with reading signature bytes in terminal mode, throwing its output into doubt.
```
$ avrdude -c arduino -C avrconf.conf -p m328p -D -u -s -t -P /dev/ttyACM0

avrdude: AVR device initialized and ready to accept instructions

Reading | #################### | 100% 0.00s
avrdude: Device signature = 0x1e950f (probably m328p)
avrdude> send 0x58 0x0 0x0 0x0
>>> send 0x58 0x0 0x0 0x0
avrdude: stk500_cmd(): programmer is out of sync
results: 98 72 00 00        ; This behavior seems to change every time!

avrdude> sig
>>> sig

Reading |                      | 0% 0.00s
avrdude: arduino_read_sig_bytes(): (a) protocol error, expect=0x14, resp=0x00
avrdude: error reading signature data for part "ATmega382P", rc=-2
error reading signature data, rc=-2
Device signature = 0xffffff        ; Bro what? You read the signature correctly
                                   ; when avrdude first launched!
```
Considering something like reading the device signature is working when `avrdude` launches automatically but failing when reading the signature manually in `avrdude`'s terminal mode, I'm more inclined to trust my code than
`avrdude` when it comes to reading the lock and high fuse bytes. My code's output also fits the results of my empirical research better since a high fuse byte of 0 would mean I have a 2KB bootloader. There's still one more
snag here that I should disclose: the code I wrote on the Arduino IDE outputs the same lock byte as my Rust code, but it outputs a high fuse byte of 0. That being said though, I dumped the Arduino's flash memory using my main
dev environment after flashing it on Arduino IDE 1.8.9, and it also suggests the bootloader starts in the last 512 bytes. But again, considering the lock byte read is the same, I'll chalk it down to some implementation details
on the Arduino IDE that I missed or a small bug in my code that occurred while porting my inline assembly from `src/bootbits.rs` over.

#### Implications

When allowing firmware updates, we need a way to recover from a bad update and also track the status of our system. From my intuition, the `BOOTRST` fuse being set to `0` and the `BLB11` and `BLB12` bits being set to `1` mean
that we have a locked bootloader and that we probably boot into the bootloader, which then jumps us into the program once the boot sequence is complete. Regardless of what approach we choose, I think our best best is to
split the flash memory into *roughly* two equal chunks, corresponding to an original and backup program.

My gut feeling is that the bootloader mostly sets stuff up internally and jumps to `0x0000`. Disassembling the `.elf` file generated by Rust has it so that the `.text` section of the file starts with a bunch of vectors anyway,
with the end result being we jump to `0x0068`. We do some setup code from there and eventually jump into what would correspond to the entry point defined in our code.
```assembly
00000092 <.do_clear_bss_loop>:
    st      X+, r1
00000094 <.do_clear_bss_start>:
    cpi     r26, 0xA6
    cpc     r27, r18
    brne    .-8
    call    0x176        ; 0x176 <main>
    jmp     0x3a2        ; 0x3a2 <_exit>
...
00000176 <main>:
#[arduino_hal::entry]    ; address 0x0176 in disassembly
    call    0x017a       ; seems pointless? but what would I know LOL
fn main() -> ! {         ; address 0x017a in disassembly
    push    r12
    push    r13
```
Now, what does this actually mean for my project development from now on? I might consider taking a conservative approach and setting `BLB12` to `1` so we allow ourselves to at least read the bootloader. Maybe we could
dump the contents of the bootloader and pass it into an AVR assembler to see what we get. If it doesn't seem like the bootloader isn't doing much other than a jump to `0x0000` or something, we could always just set
`BOOTRST` to `1` (?) and set the boot locker bits (`BLBxx`) to `1` to have a fully unlocked bootloader. On the other hand, if there's some sort of arcane magic happening, I could try to experiment with my code in my `main()`
function and then dump the first couple hundred or thousand bytes of flash memory via console output. If we write faux-bootloader code in the beginning of the `main()` function and then delineate it with an `asm!()` block
that fills some SRAM or registers with some good old `69`s, we should be able to see where and when this happens in both our disassembled output `.elf` and the flash memory dump we did. If we keep that in mind and only
overwrite application memory past the faux-bootloader, we should be able to stop ourselves from "bricking" our board. [^6]

The EEPROM could also be a nice little place to store a faux-bootloader, but I'm not sure if we can even run instructions directly from there. It's worth considering in the future, though that path might involve raw-dogging
lots of assembly code by hand.

After trying to figure out why `avrdude` and my Rust code were outputting different values entirely and concluding that `avrdude` is just acting wonky due to either a bug or an installation error on my part, I think my best
bet for implementing firmware update functionality is to go with a hacky A/B firmware update method. Considering the stock bootloader is probably making it easy to interface with my computer and flash new images as needed,
I think I should leave the bootloader alone and split the application section of the flash memory into halves. The A/B method was what I had intuitively settled upon in terms of overall complexity, and after browsing this Reddit
[thread](https://www.reddit.com/r/embedded/comments/1igkk0x/any_good_tutorials_on_safe_firmware_updates/) just to quickly explore other implementation ideas for firmware update capability, it seems I've made a good choice
~~, praise be to my computer science instincts!~~. This [comment](https://www.reddit.com/r/embedded/comments/1igkk0x/comment/mapqgy4/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)
on that post makes a great point about needing position-independent code. Because I'm not planning to mess with the stock bootloader, this will probably make things a lot harder. My intution says that I'll need to run a
bunch of setup code (essentially a hacky bootloader) that's guaranteed to not change between different firmware, i.e:

```Rust
// firmware1/main.rs

// BEGIN HACKY BOOTLOADER OF SORTS

// At the time of writing, I'm still approaching Rust from an extremely hacky angle; these seem similar to precompiler directives.
// For all firmware versions, the same preprocessor directives should be used for consistency.
#![no_std]
#![no_main]
#![feature(asm_experimental_arch)]

// This seems to be required? Again, I'm really just hacking stuff together!
use panic_halt as _;

// The libraries used should be the same.
use some::library1;
use some::library2;

// Define the same functions here as well, just to be safe!
fn foo() {
    let bar = 0;
    do_something();
}

#[arduino_hal::entry]
fn main() -> ! {
    if FW_STATUS == FW_STATUS_UPDATING {
        asm!(
            "jmp {FW_BACKUP_JMPTARGET}",
        );
    } else if FW_STATUS == FW_STATUS_OTHER {
        do_fw_stuff();
    } else {
        main_routine();
    }
}

// END HACKY BOOTLOADER
fn main_routine() {
    do_the_things();
}
```
```Rust
// firmware2/main.rs

// Note that these "pre-processor directives are the same!
#![no_std]
#![no_main]
#![feature(asm_experimental_arch)]

// The use statements too!
use panic_halt as _;
use some::library1;
use some::library2;

// Some code omitted for brevity...
#[arduino_hal::entry]
fn main() -> ! {
    if CHECKS_HERE {
        etc();
    } else {
        main_routine();
    }
}

// End of hacky bootloader
fn main_routine() {
    do_something_else();
}
```
Since Rust is a low-level language, I can usually get a vague idea of what's going on by eyeballing my code's disassembly. I noticed a lot of assembly running before we actually jumped into our entry point, so there's
probably lots of setup code going on. I'd imagine that's stuff like loading the addresses of string literals used in our code and functions used in our code and setting up for serial output (like the 
`static CONSOLE: interrupt<...>` line in `src/bootbits.rs`. Because we're not coding our bootloader from scratch (both because that's too complex and because the bootloader probably simplies plugging the board into our
computer and flashing new programs), we need to predict how the compiler will behave. If the initial assembly programmed by our firmware is always the same between firmware images, it should make recovering from a failed
firmware update consistent:
- If a firmware update goes bad, we can just reset the board. The board has been keeping track of our firmware state by storing values in EEPROM.
- When we reset, we start in the (real) bootloader and likely jump to `0x0` in flash memory. From there, our program runs. Note how in the example `firmware1/main.rs` code, our `main()` function checks the status of our
  firmware. Because our firmware images have identical "hacky bootloader" code sections, even if our firmware update didn't complete completely, as long as it made it past (TODO: finish edit).

## How to run

1. Install prerequisites as described in the [`avr-hal` README] (`avr-gcc`, `avr-libc`, `avrdude`, [`ravedude`]).

2. Run `cargo build` to build the firmware.

3. Run `cargo run` to flash the firmware to a connected board.  If `ravedude`
   fails to detect your board, check its documentation at
   <https://crates.io/crates/ravedude>.

4. `ravedude` will open a console session after flashing where you can interact
   with the UART console of your board.

[`avr-hal` README]: https://github.com/Rahix/avr-hal#readme
[`ravedude`]: https://crates.io/crates/ravedude

## License
Licensed under either of

 - Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
 - MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

## Contribution
Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall
be dual licensed as above, without any additional terms or conditions.



[^1]:The two highest bits of the lock byte were set to `0` in my code after extraction.
[^2]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1205581
[^3]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204619
[^4]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204617
[^5]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204744
[^6]:Realistically, I don't see ourselves bricking the board, especially if we keep `BLB11` and `BLB12` set to `0` so the bootloader section of flash memory is RW-protected.
