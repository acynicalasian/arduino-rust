arduino-rust
============
*last edited on 22 April 2025*

This is a personal project of mine to learn both Rust and embedded systems programming. My code was developed for
an Arduino Uno R3 from Elegoo. I aim to implement a "firmware update" functionality. As of now, the `README.md` file
serves as a diary detailing my thoughts for the development process, both for readers to understand how I think as
a fledging embedded systems programmer and for myself to ponder my design choices on "paper". If I have a complete
product in the future, I"ll likely move the dev diary part of this `README.md` to a separate `.md` file.

The contents of the **How to run** and **License** section were autogenerated by following the instructions to
initialize a project at <https://github.com/Rahix/avr-hal>.

## Bootloader analysis

### Bootloader details

[Optiboot](https://github.com/Optiboot/optiboot) (or at least an older version) claims to be installed by default
on all Arduino Uno boards, so I can expect the bootloader to be 512 bytes in size. However, to avoid any tomfoolery
stemming from running Rust on Arduino and any potential differences due to using an older version of Optiboot and
to also deepen my understanding of embedded systems, AVR assembly, and the overall microarchitecture of the
ATmega328p, I decided to verify it myself by writing code to check the relevant bits. This code is located in
`src/bootbits.rs`.

#### Results
Running the code in `src/bootbits.rs` gave me the following console output:[^1]
```
Value of lock bits: 15     # Corresponds to 0b00001111
Value of boot bits: 222    # Corresponds to 0b11011110
```

I followed the [instructions](https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204962)
given by the datasheet for the ATmega328p to extract the lock bits and the fuse high byte. Note this information from the documentation:

```
Lock bits

Bit        7        6        5        4        3        2        1        0
Rd     [   -   ][   -   ][ BLB12 ][ BLB11 ][ BLB02 ][ BLB01 ][  LB2  ][  LB1  ]
```
```
Fuse high bits

Bit        7        6        5        4        3        2        1        0
Rd     [  FHB7 ][  FHB6 ][  FHB5 ][  FHB4 ][  FHB3 ][  FHB2 ][  FHB1 ][  FHB0 ]

FHB2 corresponds to BOOTSZ1 bit
FHB1 corresponds to BOOTSZ0 bit
FBH0 corresponds to BOOTRST bit
```

We now know the following information from the lock bits:
- `LB2` and `LB1` are both `1`; we are able to read and write the flash memory in serial and parallel mode. [^2]
- `BLB12` and `BLB11` have been set to `0`; the bootloader section of the flash memory is RW-protected. `BLB02` and `BLB01` have been set to `1`; we can freely read and write the application section of the flash memory. [^3]

From the fuse high bits, we now know the following information:
- `BOOTSZ1` and `BOOTSZ0` are both `1`; this means that our bootloader is 256 words. Each AVR instruction (word) is 2 bytes... so as expected, our bootloader is 512 bytes. [^4]
- `BOOTRST` is set to `0`; from my understanding, this means we jump to the bootloader when we reset? [^5]

For whatever reason, `avrdude` states that the lock and high fuse bytes are both `0` when reading them with the shell command 
`avrdude -C avrconf.conf -c arduino -p m328p -P /dev/ttyACM0 -D -u -s -U hfuse:r:outfile1:h -U lock:r:outfile2:h`. This can't be right, however, because I've confirmed manually by dumping the contents of the Arduino's flash memory 
that the bootloader section occupies 512 bytes of flash memory. Furthermore, I've actually copied the functionality of `src/bootbits.rs` into a quick program I wrote using the Arduino IDE, and both my "stable" Arduino IDE
program and my Rust program to check the lock byte output the same results, meaning that it probably isn't a bug with the inline assembly code that I wrote. Also, `avrdude` seems to be exhibiting buggy behavior with sending 4-byte
serial programming instructions and with reading signature bytes in terminal mode, throwing its output into doubt.
```
$ avrdude -c arduino -C avrconf.conf -p m328p -D -u -s -t -P /dev/ttyACM0

avrdude: AVR device initialized and ready to accept instructions

Reading | #################### | 100% 0.00s
avrdude: Device signature = 0x1e950f (probably m328p)
avrdude> send 0x58 0x0 0x0 0x0
>>> send 0x58 0x0 0x0 0x0
avrdude: stk500_cmd(): programmer is out of sync
results: 98 72 00 00        ; This behavior seems to change every time!

avrdude> sig
>>> sig

Reading |                      | 0% 0.00s
avrdude: arduino_read_sig_bytes(): (a) protocol error, expect=0x14, resp=0x00
avrdude: error reading signature data for part "ATmega382P", rc=-2
error reading signature data, rc=-2
Device signature = 0xffffff        ; Bro what? You read the signature correctly
                                   ; when avrdude first launched!
```
Considering something like reading the device signature is working when `avrdude` launches automatically but failing when reading the signature manually in `avrdude`'s terminal mode, I'm more inclined to trust my code than
`avrdude` when it comes to reading the lock and high fuse bytes. My code's output also fits the results of my empirical research better since a high fuse byte of 0 would mean I have a 2KB bootloader. There's still one more
snag here that I should disclose: the code I wrote on the Arduino IDE outputs the same lock byte as my Rust code, but it outputs a high fuse byte of 0. That being said though, I dumped the Arduino's flash memory using my main
dev environment after flashing it on Arduino IDE 1.8.9, and it also suggests the bootloader starts in the last 512 bytes. But again, considering the lock byte read is the same, I'll chalk it down to some implementation details
on the Arduino IDE that I missed or a small bug in my code that occurred while porting my inline assembly from `src/bootbits.rs` over.

#### Implications

When allowing firmware updates, we need a way to recover from a bad update and also track the status of our system. From my intuition, the `BOOTRST` fuse being set to `0` and the `BLB11` and `BLB12` bits being set to `1` mean
that we have a locked bootloader and that we probably boot into the bootloader, which then jumps us into the program once the boot sequence is complete. Regardless of what approach we choose, I think our best best is to
split the flash memory into *roughly* two equal chunks, corresponding to an original and backup program.

My gut feeling is that the bootloader mostly sets stuff up internally and jumps to `0x0000`. Disassembling the `.elf` file generated by Rust has it so that the `.text` section of the file starts with a bunch of vectors anyway,
with the end result being we jump to `0x0068`. We do some setup code from there and eventually jump into what would correspond to the entry point defined in our code.
```assembly
00000092 <.do_clear_bss_loop>:
    st      X+, r1
00000094 <.do_clear_bss_start>:
    cpi     r26, 0xA6
    cpc     r27, r18
    brne    .-8
    call    0x176        ; 0x176 <main>
    jmp     0x3a2        ; 0x3a2 <_exit>
...
00000176 <main>:
#[arduino_hal::entry]    ; address 0x0176 in disassembly
    call    0x017a       ; seems pointless? but what would I know LOL
fn main() -> ! {         ; address 0x017a in disassembly
    push    r12
    push    r13
```
Now, what does this actually mean for my project development from now on? I might consider taking a conservative approach and setting `BLB12` to `1` so we allow ourselves to at least read the bootloader. Maybe we could
dump the contents of the bootloader and pass it into an AVR assembler to see what we get. If it doesn't seem like the bootloader isn't doing much other than a jump to `0x0000` or something, we could always just set
`BOOTRST` to `1` (?) and set the boot locker bits (`BLBxx`) to `1` to have a fully unlocked bootloader. On the other hand, if there's some sort of arcane magic happening, I could try to experiment with my code in my `main()`
function and then dump the first couple hundred or thousand bytes of flash memory via console output. If we write faux-bootloader code in the beginning of the `main()` function and then delineate it with an `asm!()` block
that fills some SRAM or registers with some good old `69`s, we should be able to see where and when this happens in both our disassembled output `.elf` and the flash memory dump we did. If we keep that in mind and only
overwrite application memory past the faux-bootloader, we should be able to stop ourselves from "bricking" our board. [^6]

The EEPROM could also be a nice little place to store a faux-bootloader, but I'm not sure if we can even run instructions directly from there. It's worth considering in the future, though that path might involve raw-dogging
lots of assembly code by hand.

## Firmware update process

### Design notes

After trying to figure out why `avrdude` and my Rust code were outputting different values entirely and concluding that `avrdude` is just acting wonky due to either a bug or an installation error on my part, I think my best
bet for implementing firmware update functionality is to go with a hacky A/B firmware update method. Considering the stock bootloader is probably making it easy to interface with my computer and flash new images as needed,
I think I should leave the bootloader alone and split the application section of the flash memory into halves. The A/B method was what I had intuitively settled upon in terms of overall complexity, and after browsing this Reddit
[thread](https://www.reddit.com/r/embedded/comments/1igkk0x/any_good_tutorials_on_safe_firmware_updates/) just to quickly explore other implementation ideas for firmware update capability, it seems I've made a good choice
~~, praise be to my computer science instincts!~~. This [comment](https://www.reddit.com/r/embedded/comments/1igkk0x/comment/mapqgy4/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button)
on that post makes a great point about needing position-independent code. However, we might not need position-independent code if we do the following:

1) We'll adopt a faux-A/B firmware update model. The first half of the application section of flash memory is our current firmware and where we'll overwrite when updating the firmware. The second half of the application section
   of flash memory is a backup image of our current firmware.
2) We'll enforce that every firmware image has the same starting code (identical "hacky bootloaders"). So something like:
   ```Rust
   // firmware1/main.rs
  
   // BEGIN HACKY BOOTLOADER
   
   // At the time of writing, I'm still approaching Rust from an extremely hacky angle; these seem similar to precompiler directives.
   // For all firmware versions, the same preprocessor directives should be used for consistency.
   #![no_std]
   #![no_main]
   #![feature(asm_experimental_arch)]
   
   // This seems to be required? Again, I'm really just hacking stuff together!
   use panic_halt as _;
  
   // The libraries used should be the same.
   use some::library1;
   use some::library2;
  
   // Define the same functions here as well, just to be safe!
   fn foo() {
       let bar = 0;
       do_something();
   }
  
   #[arduino_hal::entry]
   fn main() -> ! {
       if FW_STATUS == FW_STATUS_UPDATING {
           asm!(
               "jmp {FW_BACKUP_JMPTARGET}",
           );
       } else if FW_STATUS == FW_STATUS_OTHER {
           do_fw_stuff();
       } else {
           main_routine();
       }
   }
  
   // END HACKY BOOTLOADER
   fn main_routine() {
       do_the_things();
   }
   ```
   ```Rust
   // firmware2/main.rs
   /** INSERT HACKY BOOTLOADER CODE HERE! **/
   fn main_routine() {
       do_something_else();
   }
   ```
   My design choice to force firmware versions to have identical hacky bootloaders operates on the assumption that if my source code files all start the same way and only have different `main_routine()` functions, the
   compiler will always output identical code for the initial chunk of assembly that represents various setup code that occurs before our entry point defined in our code (`#[arduino_hal::entry]`) and
   the code contained in `main()`. Making debuggable code will likely be difficult as I'm relying on serial output to debug my code (I have no clue if there's a better way to do this!), and I'll need to account for how
   the compiler stores string literals. However, I think forcing the "hacky bootloader" to be the same across firmware versions offers the following benefits for making the firmware update process robust:
   - If I decide to make implementation simpler by rewriting the entire first half of application memory every time we do a firmware update or restore, then as long as a failed firmware update proceeded past the hacky
     bootloader section of our code, then starting our board after a bad firmware update process should still always land us in valid hacky bootloader code that'll contain the code necessary for us to recover by
     reverting to our backup firmware image. If the firmware update process failed while writing to the section of flash memory occupied by the hacky bootloader and it led to a corrupted write, we likely have bigger
     problems and have "bricked" our board (in the sense of it probably can't be updated anymore without flashing new firmware externally using `avrdude`). That, however, brings me to my second point.
   - Having a hacky bootloader consistent across firmware versions opens the possibility of simply never touching the bootloader during firmware update processes. This should make the firmware update process even more
     robust and opens the possiblility of only really needing to copy and back up the assembly represented by `main_routine()`, which will allow slightly larger firmware versions.

#### Messing with linker scripts

Using this goated [source](https://mcyoung.xyz/2021/06/01/linker-script/), I think things might be clicking for me a bit. Let's compare some of the output from
`avr-objdump -x /target/avr-atmega328p/debug/arduino-rust.elf` with that from `avr-objdump -Ds flashdump.elf`.

```
arduino-rust.elf:     file format elf32-avr
arduino-rust.elf
architecture: avr:5, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000

Program Header:
    LOAD off    0x000000b4 vaddr 0x00000000 paddr 0x00000000 align 2**1
         filesz 0x000001dc memsz 0x000001dc flags r-x
    LOAD off    0x00000290 vaddr 0x00800100 paddr 0x000001dc align 2**0
         filesz 0x00000066 memsz 0x00000066 flags rw-
    LOAD off    0x000002f6 vaddr 0x00800166 paddr 0x00800166 align 2**0
         filesz 0x00000000 memsz 0x00000004 flags rw-
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000066  00800100  000001dc  00000290  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001dc  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800166  00800166  000002f6  2**0
                  ALLOC
```
```
flashdump.elf:    file format elf32-avr

Contents of section .data:
; ...
 01c0 e1000e94 eb008be3 91e06be2 70e00e94  ..........k.p...
 01d0 df000e94 e100ffcf f894ffcf 77656c6c  ............well
 01e0 20776861 74206861 7070656e 73206865   what happens he
 01f0 72653f61 73736572 74696f6e 20666169  re?assertion fai
 0200 6c65643a 2069735f 77726974 696e6728  led: is_writing(
 0210 626f7272 6f772963 616c6c65 6420604f  borrow)called `O
 0220 7074696f 6e3a3a75 6e777261 70282960  ption::unwrap()`
 0230 206f6e20 6120604e 6f6e6560 2076616c   on a `None` val
 0240 7565ffff ffffffff ffffffff ffffffff  ue..............
 0250 ffffffff ffffffff ffffffff ffffffff  ................
; ...
```

Viewing the sections of our ELF file, we see that the `.data` section has a LMA (load memory address) of `0x01dc` and a VMA (virtual memory address) of `0x00800100`. As we can see from the dump of the flash memory, we
find our string literals at that exact part of memory. Hmm, that's interesting, but even more things are clicking for me from there onwards. Below is disassembled code from our flash dump, `avr-objdump -DS flashdump.elf`:

```assembly
      68:       11 24           eor     r1, r1
      6a:       1f be           out     0x3f, r1        ; 63
      6c:       cf ef           ldi     r28, 0xFF       ; 255
      6e:       d8 e0           ldi     r29, 0x08       ; 8
      70:       de bf           out     0x3e, r29       ; 62
      72:       cd bf           out     0x3d, r28       ; 61
      74:       11 e0           ldi     r17, 0x01       ; 1
      76:       a0 e0           ldi     r26, 0x00       ; 0
      78:       b1 e0           ldi     r27, 0x01       ; 1
      7a:       ec ed           ldi     r30, 0xDC       ; 220
      7c:       f1 e0           ldi     r31, 0x01       ; 1
      7e:       02 c0           rjmp    .+4             ; 0x84 <_binary_flashdump_start+0x84>
      80:       05 90           lpm     r0, Z+
      82:       0d 92           st      X+, r0
      84:       a6 36           cpi     r26, 0x66       ; 102
      86:       b1 07           cpc     r27, r17
      88:       d9 f7           brne    .-10            ; 0x80 <_binary_flashdump_start+0x80>
      8a:       21 e0           ldi     r18, 0x01       ; 1
      8c:       a6 e6           ldi     r26, 0x66       ; 102
      8e:       b1 e0           ldi     r27, 0x01       ; 1
      90:       01 c0           rjmp    .+2             ; 0x94 <_binary_flashdump_start+0x94>
      92:       1d 92           st      X+, r1
      94:       aa 36           cpi     r26, 0x6A       ; 106
      96:       b2 07           cpc     r27, r18
      98:       e1 f7           brne    .-8             ; 0x92 <_binary_flashdump_start+0x92>
      9a:       0e 94 53 00     call    0xa6            ; 0xa6 <_binary_flashdump_start+0xa6>
```
Interrupt vectors (I think that's what they're called?) are stored at `0x0`, and we see that after a board reset (or at least as far as I can tell, whenever our board's program runs), we `jmp` to `0x68`. Stepping
through the code from there, let's make a few notes of things. We can ignore `0x68` to `0x72`. [^7] At `0x74`, we're holding `r17`. Then, at `0x76` and `0x78`, we're setting the `X` register to `0x0100`, which
corresponds to the beginning of SRAM. We then set the `Z` register to `0x01dc` (!) at `0x7a` and `0x7c`. We `rjmp` at `0x7e` to `0x84`, where we compare the low byte of the `X` register to `0x66`. Hmm, didn't the
ELF file mention the size of the `.data` section was `0x66`? Anyhow, at `0x86`, we compare `r17` and the the high byte of the `X` register (`r26`). At this point, it's becoming clear what the code is trying to do so I
won't bother getting into the nitty gritty of the carry bits ~~(nor do I want to, when a heuristic analysis is good enough)~~, but our `cpc` instruction at `0x86` should lead us to follow the conditional `brne` 
relative jump at `0x88`. At `0x80`, we're *loading from program memory* the byte stored at the address stored in the `Z` register. Note that our `Z` register was pointing to `0x01dc`, the LMA of the `.data` section
according to the ELF file and where we found our string literals in the dump of our Arduino's flash memory! At `0x82`, we store `r0` at the address pointed by the `X` register and then increment the `X` register. Hmm,
the `X` register was holding `0x0100` when we last checked, which happens to correspond to the beginning of SRAM. And although `0x00800100` wouldn't be a valid memory address in the address space of our MCU, dropping
the top four bits gives us another `0x0100`, which lines up with the VMA of our `data` section. This can't be a coincidence, and the purpose of this code becomes pretty clear. We compare the lower byte of the `X`
register again at `0x84`, and now it becomes clear that we're probably looping `0x66` times in the code to copy the string literals in our program to the beginning of SRAM.

I've learned a couple things from this. First, this confirms that our compiler is automatically storing string literals past the code section of our flash memory. Second, I can probably use the `-x` option of
`avr-objdump` to see the ELF headers and see where the compiler is deciding to store string literals. The problem is, I want to make sure some of the string literals always end up in our hacky bootloader because we
need access to strings to label diagnostic info in our serial output.

This is where tweaking our linker comes in. Doing a bit of high-level research in ChatGPT, I've come across two methods to make sure our hacky bootloader contains diagnostic strings. The first method could be to bury
our text data as raw bytes in inline assembly. [^8] To the best of my knowledge, `asm!()` blocks can't really be optimized by our compiler, so any `asm!()` blocks I write should end up intact in compiled code.
```assembly
ldi r16, 0x45                    ; foo
rjmp .+18                        ; jump past the next 18 bytes, which contain raw byte data that doesn't correspond to (intended) code
dxstr: .DB "Not 0-terminated!"   ; we have an odd # of chars; I believe we'll probably get a zero-byte here automatically.
ldi r17, 0x45                    ; if we label this line, I believe we can rjmp to it using the label as well.
```
I'm a bit hesitant about this first method because it could be a massive PITA to actually extract our string literals from program memory when using `println!()`. I'm not even sure if this code would work in inline
assembly because some of this code came from the guide to the [AVR assembler](https://ww1.microchip.com/downloads/en/DeviceDoc/40001917A.pdf). With or without labels in assembly, could I easily refer back to where I
stored my string literals in program memory? There's just too many questions.

From a bit of high-level research using ChatGPT as a guide, apparently I can create a linker script and label sections of code with `![unsafe(link_section=".my_section_name_here")]`. That's where this
[guide](https://mcyoung.xyz/2021/06/01/linker-script/) is probably gonna carry me. For now, this is the approach I've settled on to write and structure my hacky bootloader.

## How to run

1. Install prerequisites as described in the [`avr-hal` README] (`avr-gcc`, `avr-libc`, `avrdude`, [`ravedude`]).

2. Run `cargo build` to build the firmware.

3. Run `cargo run` to flash the firmware to a connected board.  If `ravedude`
   fails to detect your board, check its documentation at
   <https://crates.io/crates/ravedude>.

4. `ravedude` will open a console session after flashing where you can interact
   with the UART console of your board.

[`avr-hal` README]: https://github.com/Rahix/avr-hal#readme
[`ravedude`]: https://crates.io/crates/ravedude

## License
Licensed under either of

 - Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
 - MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

## Contribution
Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall
be dual licensed as above, without any additional terms or conditions.



[^1]:The two highest bits of the lock byte were set to `0` in my code after extraction.
[^2]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1205581
[^3]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204619
[^4]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204617
[^5]:https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf#G1204744
[^6]:Realistically, I don't see ourselves bricking the board, especially if we keep `BLB11` and `BLB12` set to `0` so the bootloader section of flash memory is RW-protected.
[^7]:`0x68` should zero out `r1`. `0x6a` zeroes out the register that holds carry bits. `0x6c` and `0x6e` sets the `Y` register to `0x8ff`, which corresponds to the highest address in SRAM. `0x70` and `0x72` set the
high and low bytes of the stack register respectively.
[^8]:https://ww1.microchip.com/downloads/en/DeviceDoc/40001917A.pdf#_OPENTOPIC_TOC_PROCESSING_d114e1545
